# Copyright: Ankitects Pty Ltd and contributors
# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html

# This file is automatically generated; edit tools/genhooks.py instead.
# Please import from anki.hooks instead of this file.

# pylint: disable=unused-import

from __future__ import annotations

from typing import Any, Callable, Sequence
import anki
import anki.hooks
from anki.cards import Card
from anki.notes import Note


class _CardDidLeechHook:
    """Called by v1/v2 scheduler when a card is marked as a leech."""

    _hooks: list[Callable[["Card"], None]] = []

    def append(self, callback: Callable[["Card"], None]) -> None:
        """(card: Card)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["Card"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, card: Card) -> None:
        for hook in self._hooks:
            try:
                hook(card)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise
        # legacy support
        anki.hooks.runHook("leech", card)


card_did_leech = _CardDidLeechHook()


class _CardDidRenderHook:
    """Can modify the resulting text after rendering completes."""

    _hooks: list[
        Callable[
            [
                "anki.template.TemplateRenderOutput",
                "anki.template.TemplateRenderContext",
            ],
            None,
        ]
    ] = []

    def append(
        self,
        callback: Callable[
            [
                "anki.template.TemplateRenderOutput",
                "anki.template.TemplateRenderContext",
            ],
            None,
        ],
    ) -> None:
        """(output: anki.template.TemplateRenderOutput, ctx: anki.template.TemplateRenderContext)"""
        self._hooks.append(callback)

    def remove(
        self,
        callback: Callable[
            [
                "anki.template.TemplateRenderOutput",
                "anki.template.TemplateRenderContext",
            ],
            None,
        ],
    ) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(
        self,
        output: anki.template.TemplateRenderOutput,
        ctx: anki.template.TemplateRenderContext,
    ) -> None:
        for hook in self._hooks:
            try:
                hook(output, ctx)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


card_did_render = _CardDidRenderHook()


class _CardOdueWasInvalidHook:
    _hooks: list[Callable[[], None]] = []

    def append(self, callback: Callable[[], None]) -> None:
        """()"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[[], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self) -> None:
        for hook in self._hooks:
            try:
                hook()
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


card_odue_was_invalid = _CardOdueWasInvalidHook()


class _CardWillFlushHook:
    """Allow to change a card before it is added/updated in the database."""

    _hooks: list[Callable[["Card"], None]] = []

    def append(self, callback: Callable[["Card"], None]) -> None:
        """(card: Card)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["Card"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, card: Card) -> None:
        for hook in self._hooks:
            try:
                hook(card)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


card_will_flush = _CardWillFlushHook()


class _DeckAddedHook:
    """Obsolete, do not use."""

    _hooks: list[Callable[["anki.decks.DeckDict"], None]] = []

    def append(self, callback: Callable[["anki.decks.DeckDict"], None]) -> None:
        """(deck: anki.decks.DeckDict)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["anki.decks.DeckDict"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, deck: anki.decks.DeckDict) -> None:
        for hook in self._hooks:
            try:
                hook(deck)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


deck_added = _DeckAddedHook()


class _ExportersListCreatedHook:
    _hooks: list[Callable[["list[tuple[str, Any]]"], None]] = []

    def append(self, callback: Callable[["list[tuple[str, Any]]"], None]) -> None:
        """(exporters: list[tuple[str, Any]])"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["list[tuple[str, Any]]"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, exporters: list[tuple[str, Any]]) -> None:
        for hook in self._hooks:
            try:
                hook(exporters)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise
        # legacy support
        anki.hooks.runHook("exportersList", exporters)


exporters_list_created = _ExportersListCreatedHook()


class _FieldFilterFilter:
    """Allows you to define custom {{filters:..}}

    Your add-on can check filter_name to decide whether it should modify
    field_text or not before returning it."""

    _hooks: list[
        Callable[["str", "str", "str", "anki.template.TemplateRenderContext"], str]
    ] = []

    def append(
        self,
        callback: Callable[
            ["str", "str", "str", "anki.template.TemplateRenderContext"], str
        ],
    ) -> None:
        """(field_text: str, field_name: str, filter_name: str, ctx: anki.template.TemplateRenderContext)"""
        self._hooks.append(callback)

    def remove(
        self,
        callback: Callable[
            ["str", "str", "str", "anki.template.TemplateRenderContext"], str
        ],
    ) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(
        self,
        field_text: str,
        field_name: str,
        filter_name: str,
        ctx: anki.template.TemplateRenderContext,
    ) -> str:
        for filter in self._hooks:
            try:
                field_text = filter(field_text, field_name, filter_name, ctx)
            except:
                # if the hook fails, remove it
                self._hooks.remove(filter)
                raise
        return field_text


field_filter = _FieldFilterFilter()


class _ImportingImportersHook:
    """Allows updating the list of importers.
    The resulting list is not saved and should be changed each time the
    filter is called.

    NOTE: Updates to the import/export code are expected in the coming
    months, and this hook may be replaced with another solution at that
    time. Tracked on https://github.com/ankitects/anki/issues/1018"""

    _hooks: list[Callable[["list[tuple[str, Any]]"], None]] = []

    def append(self, callback: Callable[["list[tuple[str, Any]]"], None]) -> None:
        """(importers: list[tuple[str, Any]])"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["list[tuple[str, Any]]"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, importers: list[tuple[str, Any]]) -> None:
        for hook in self._hooks:
            try:
                hook(importers)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


importing_importers = _ImportingImportersHook()


class _LegacyExportProgressHook:
    """Temporary hook used in transition to new import/export code."""

    _hooks: list[Callable[["str"], None]] = []

    def append(self, callback: Callable[["str"], None]) -> None:
        """(progress: str)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["str"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, progress: str) -> None:
        for hook in self._hooks:
            try:
                hook(progress)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


legacy_export_progress = _LegacyExportProgressHook()


class _MediaFileFilterFilter:
    """Allows manipulating the file path that media will be read from"""

    _hooks: list[Callable[["str"], str]] = []

    def append(self, callback: Callable[["str"], str]) -> None:
        """(txt: str)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["str"], str]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, txt: str) -> str:
        for filter in self._hooks:
            try:
                txt = filter(txt)
            except:
                # if the hook fails, remove it
                self._hooks.remove(filter)
                raise
        return txt


media_file_filter = _MediaFileFilterFilter()


class _MediaFilesDidExportHook:
    """Only used by legacy .apkg exporter. Will be deprecated in the future."""

    _hooks: list[Callable[["int"], None]] = []

    def append(self, callback: Callable[["int"], None]) -> None:
        """(count: int)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["int"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, count: int) -> None:
        for hook in self._hooks:
            try:
                hook(count)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


media_files_did_export = _MediaFilesDidExportHook()


class _NoteTypeAddedHook:
    """Obsolete, do not use."""

    _hooks: list[Callable[["anki.models.NotetypeDict"], None]] = []

    def append(self, callback: Callable[["anki.models.NotetypeDict"], None]) -> None:
        """(notetype: anki.models.NotetypeDict)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["anki.models.NotetypeDict"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, notetype: anki.models.NotetypeDict) -> None:
        for hook in self._hooks:
            try:
                hook(notetype)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


note_type_added = _NoteTypeAddedHook()


class _NoteWillFlushHook:
    """Allow to change a note before it is added/updated in the database."""

    _hooks: list[Callable[["Note"], None]] = []

    def append(self, callback: Callable[["Note"], None]) -> None:
        """(note: Note)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["Note"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, note: Note) -> None:
        for hook in self._hooks:
            try:
                hook(note)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


note_will_flush = _NoteWillFlushHook()


class _NotesWillBeDeletedHook:
    _hooks: list[
        Callable[["anki.collection.Collection", "Sequence[anki.notes.NoteId]"], None]
    ] = []

    def append(
        self,
        callback: Callable[
            ["anki.collection.Collection", "Sequence[anki.notes.NoteId]"], None
        ],
    ) -> None:
        """(col: anki.collection.Collection, ids: Sequence[anki.notes.NoteId])"""
        self._hooks.append(callback)

    def remove(
        self,
        callback: Callable[
            ["anki.collection.Collection", "Sequence[anki.notes.NoteId]"], None
        ],
    ) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(
        self, col: anki.collection.Collection, ids: Sequence[anki.notes.NoteId]
    ) -> None:
        for hook in self._hooks:
            try:
                hook(col, ids)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise
        # legacy support
        anki.hooks.runHook("remNotes", col, ids)


notes_will_be_deleted = _NotesWillBeDeletedHook()


class _SchedulerNewLimitForSingleDeckFilter:
    """Allows changing the number of new card for this deck (without
    considering descendants)."""

    _hooks: list[Callable[["int", "anki.decks.DeckDict"], int]] = []

    def append(self, callback: Callable[["int", "anki.decks.DeckDict"], int]) -> None:
        """(count: int, deck: anki.decks.DeckDict)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["int", "anki.decks.DeckDict"], int]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, count: int, deck: anki.decks.DeckDict) -> int:
        for filter in self._hooks:
            try:
                count = filter(count, deck)
            except:
                # if the hook fails, remove it
                self._hooks.remove(filter)
                raise
        return count


scheduler_new_limit_for_single_deck = _SchedulerNewLimitForSingleDeckFilter()


class _SchedulerReviewLimitForSingleDeckFilter:
    """Allows changing the number of rev card for this deck (without
    considering descendants)."""

    _hooks: list[Callable[["int", "anki.decks.DeckDict"], int]] = []

    def append(self, callback: Callable[["int", "anki.decks.DeckDict"], int]) -> None:
        """(count: int, deck: anki.decks.DeckDict)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["int", "anki.decks.DeckDict"], int]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, count: int, deck: anki.decks.DeckDict) -> int:
        for filter in self._hooks:
            try:
                count = filter(count, deck)
            except:
                # if the hook fails, remove it
                self._hooks.remove(filter)
                raise
        return count


scheduler_review_limit_for_single_deck = _SchedulerReviewLimitForSingleDeckFilter()


class _Schedv2DidAnswerReviewCardHook:
    _hooks: list[Callable[["anki.cards.Card", "int", "bool"], None]] = []

    def append(
        self, callback: Callable[["anki.cards.Card", "int", "bool"], None]
    ) -> None:
        """(card: anki.cards.Card, ease: int, early: bool)"""
        self._hooks.append(callback)

    def remove(
        self, callback: Callable[["anki.cards.Card", "int", "bool"], None]
    ) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, card: anki.cards.Card, ease: int, early: bool) -> None:
        for hook in self._hooks:
            try:
                hook(card, ease, early)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


schedv2_did_answer_review_card = _Schedv2DidAnswerReviewCardHook()


class _SchemaWillChangeFilter:
    _hooks: list[Callable[["bool"], bool]] = []

    def append(self, callback: Callable[["bool"], bool]) -> None:
        """(proceed: bool)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["bool"], bool]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, proceed: bool) -> bool:
        for filter in self._hooks:
            try:
                proceed = filter(proceed)
            except:
                # if the hook fails, remove it
                self._hooks.remove(filter)
                raise
        return proceed


schema_will_change = _SchemaWillChangeFilter()


class _SyncProgressDidChangeHook:
    """Obsolete, do not use."""

    _hooks: list[Callable[["str"], None]] = []

    def append(self, callback: Callable[["str"], None]) -> None:
        """(msg: str)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["str"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, msg: str) -> None:
        for hook in self._hooks:
            try:
                hook(msg)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


sync_progress_did_change = _SyncProgressDidChangeHook()


class _SyncStageDidChangeHook:
    """Obsolete, do not use."""

    _hooks: list[Callable[["str"], None]] = []

    def append(self, callback: Callable[["str"], None]) -> None:
        """(stage: str)"""
        self._hooks.append(callback)

    def remove(self, callback: Callable[["str"], None]) -> None:
        if callback in self._hooks:
            self._hooks.remove(callback)

    def count(self) -> int:
        return len(self._hooks)

    def __call__(self, stage: str) -> None:
        for hook in self._hooks:
            try:
                hook(stage)
            except:
                # if the hook fails, remove it
                self._hooks.remove(hook)
                raise


sync_stage_did_change = _SyncStageDidChangeHook()
